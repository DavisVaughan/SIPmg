---
title: "qSIPmg"
author: "Pranav Sampara, Ryan Ziels"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float: yes
    theme: united
  pdf_document:
    toc: yes
vignette: >
  %\VignetteIndexEntry{qSIPmg}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction to qSIPmg
qSIPmg is a statistical analysis package to identify isotope incorporating MAGs using the principles of quantitative stable isotope probing (qSIP).

## Goal of qSIPmg package.
qSIPmg package was developed to assist users in statistical analyses to identify a stable isotope incorporating taxa obtained as metagenome-assembled genomes (MAGs). 

Stable isotope probing (SIP) targets active populations within complex microbiomes by providing growth substrates enriched in a heavy stable isotope of carbon, nitrogen, or oxygen. In DNA-SIP, the DNA of microbes actively incorporating the labelled substrate into their DNA during cell division and growth would become increasingly labelled and heavier compared to the microbes not incorporating the substrate into their DNA. DNA-SIP is a powerful technique to link the identity and function of environmental microbes. However, traditional DNA-SIP is only a qualitative technique to identify active microbial populations and no quantitative estimates of isotopic enrichment of DNA are provided. a qualitative analysis may mask the true incorporators and, worse, falsely identify non-incorporators as incorporators, skewing the analysis of the study. For more discussion on the power and need of quantifying isotopic enrichment in SIP studies, termed quantitative SIP (qSIP), please refer [Hungate et al. (2015)] (https://journals.asm.org/doi/abs/10.1128/AEM.02280-15). Briefly, in qSIP, quantitative estimates of isotope incorporation expressed as atom fraction excess (AFE) quantifies isotopic enrichment based on a mathematical model. Combining qSIP with molecular tools such as metagenomics, a slew of opportunities in microbial ecology opens up, such as the investigation of metabolic potential of active populations and estimation of growth rates of isotope incorporating taxa, from studies based on in-situ conditions.

Metagenomics offers a comprehensive account of the metabolic repertoire in an environment, but the data is compositional. Relative abundance of genes or taxa is estimated to determine microbial community dynamics, which is directly influenced by the dynamics of rest of the community. Even if a certain gene remains in the same concentration, its relative abundance decreases if a certain other gene increases in concentration. For quantitative measurements of microbial taxon absolute abundance in a given metagenomic sample, [Hardwick et al. (2018)] (https://www.nature.com/articles/s41467-018-05555-0) proposed synthetic spike-ins, or sequins, as internal reference standards. Reference standards in metagenomics can act as scaling factors to evaluate quantitative estimates of individual biological features, in this case, genes or genomes. 
In this vignette, a brief introduction to qSIPmg workflow is provided. Briefly, the workflow is in two parts as follows:
1.	Estimate absolute abundances from coverage values obtained from high-throughput sequencing and metagenome analyses, based on known concentrations and coverages of sequins in each fraction of the ultracentrifuged sample.
2.	Using statistical analyses and qSIP principles, identify isotope incorporators and isotopic enrichment of each biological feature from absolute abundances and buoyant densities.

# Example to show the functioning of the package.
This workflow uses a highly simplified mock dataset available on the package GitHub page. The mock experiment was simulated to have 13C and 12C carbon substrate fed community of five organisms. The simulated experiment was designed to have triplicates for each substrate addition and provide 13 fractions with a buoyant density range of 1.675 g/mL to 1.777 g/mL. It is assumed that a mix of 86 sequins was added to each fraction as reference standards to scale coverage values to absolute abundances. Genome-centric metagenomics was conducted on the mock community to recover five metagenome-assembled genomes. The coverage values and GC content of each MAG were estimated using CheckM. The taxonomic classification was done using GTDB-Tk.

## Working with the dataset

## Phase 1 - Estimate absolute abundances of MAGs
Sequins will be used as reference standards to scale coverage values to absolute concentrations (molarity)

```{r Load libraries, comment=FALSE, message=FALSE}
#Load required libraries
library(tidyverse)
library(phyloseq)
library(HTSSIP)
library(data.table)
library(ggpubr)
library(qSIPmg)
```

### Load required data 

The following files are required: \n

####MAG coverage data
-Pooled coverages data as a comma separated file (.csv file) across samples for `Features` incuding sequins that were used as spike-ins. The followings columns are required: \n   

  -Feature: A character string describing the `Feature` label \n
  
  -Sample: The label for these n number of columns should be in the format of "'isotope'\_rep\_#\_fraction\_#". For instance, "12C\_rep\_1\_fraction\_1". The number of sample columns should be the same as the product of (replicates, fractions, isotopes) \n
    
####Sequin metadata
-Load the sequins metadata as a comma separated file (.csv file) which has the following columns: \n

  -Feature: As described above \n
    
  -Length: Length of the sequin in bp \n
    
  -GC_content: GC content of the sequin \n
  
  -Sequence: Sequin nucleotide sequence \n
  
  -Concentration: Concentration of the sequin in attamoles/uL \n
    
####Dilutions data
-Load dilutions data as a comma separated file (.csv file) that contains the following columns: \n

  -Sample: Similar to the sample name as described above \n
  
  -Dilution: Dilution of sequins added to the fraction before sequencing. \n

####Fractions metadata
-A fractions file as a comma separated file (.csv file) with the following columns: \n

  -Replicate: Depends on how many replicates the study has \n
  
  -Fractions: Typically in the range of 1-24 \n
  
  -Buoyant_density: As calculated from the refractometer for each fraction and replicate \n
  
  -Isotope - "12C", "13C", "14N", "15N" etc. \n
  
  -DNA_concentration \n
  
  -Sample - In the format "'isotope'\_rep\_#\_fraction\_#". For instance 12C\_rep\_1\_fraction\_1 \n

####GTDB style taxonomy data
- A taxonomy file in the GTDB output format (.tsv format). Load the bacteria and archaea taxonomy outputs separately. The markdown requires loading the standard output files from GTDB-Tk separately for bacteria and archaea

####MAG absolute concentrations
-MAG absolute concentrations obtained from scaling_sequins.R. \n
`mag_tab` object obtained from the above script is to be used as the input here

####GC content
-GC content of the MAGs as a comma separated file (.csv file). The table should contain the following columns: \n

  -OTU: MAG identifier such as the `Feature` label from the `sequin_scaling.R` script \n
  
  -GC_content: GC content of the `Feature` in the range of 0-1 \n
  
####Log scale BOOLEAN: \n

True or False depending on how you would want the MAG coverages to be scaled. Select TRUE if you need MAG concentrations scaled on the log scale \n

####coe_of_variation: \n
Acceptable coeffi
cient of variation for coverage and detection (eg. 20 for 20 % threshold of coefficient of variation) 
Coverages above the threshold value will be flagged in the plots \n


```{r Load data, comment=FALSE, message=FALSE}
## Load data
#Coverage metadata
#Uncomment if your coverage data is in the format mentioned above for this file. Remains commented if you are using the output from `checkm coverage`
f_tibble = read_csv(file="mock_input_data/coverage_metadata.csv")

#Sequins metadata
sequins <- read_csv(file="mock_input_data/sequins_metadata.csv")

#Dilutions data
seq_dil = read_csv(file = "mock_input_data/dilutions_data.csv")

#Log scale BOOLEAN. True or False depending on how you would want the MAG coverages to be scaled. Select TRUE if you need MAG concentrations scaled on the log scale
log_scale = TRUE

#coe_of_variation. Acceptable coefficient of variation for coverage and detection (eg. 20 - for 20 % threshold of coefficient of variation) (Coverages above the threshold value will be flagged in the plots)
coe_of_variation = 20

#Taxonomy
gtdbtk_bac_summary = read_delim("mock_input_data/gtdbtk.bac120.summary.tsv", 
                                 "\t", escape_double = FALSE, trim_ws = TRUE)
gtdbtk_archaea = read_delim("mock_input_data/gtdbtk.ar122.summary.tsv", 
                             "\t", escape_double = FALSE, trim_ws = TRUE)
#GC content
GC_content <- read_csv(file = "mock_input_data/GC_content.csv")

#Fractions
fractions = read_csv("mock_input_data/fractions.csv")

#taxonomy
taxonomy_tibble = rbind(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if necessary
#mag_tab is a tibble with absolute concentrations of MAGs obtained by scaling MAG coverages using linear regression models on sequin coverages and concentration


```

### Dataset preview
Here is a preview of sample metadata, coverage values, and taxonomic classification.

``` {r preview of datasets}
#Sample metadata
head(fractions)
#Coverage values from CheckM
head(f_tibble)
#Taxonomic classification from GTDB-Tk
head(taxonomy_tibble)
```


### Scaling coverage data to absolute abundances

#### rlm scaling of coverage values
Scale coverage values to absolute abundance using the robust linear regression model

```{r rlm scaling, message=FALSE, warning=FALSE}
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#For rlm scaling using scale_features_rlm
#For rlm scaling using scale_features_lm
mag_tab_scaled <- scale_features_rlm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation)

mag_tab = as.matrix(mag_tab_scaled$mag_tab) #Extract absolute abundances as a matrix
#mag_tab = as.matrix(mag_tab) #Ensuring input for phyloseq OTU table is in a matrix format
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table

taxonomy.object = tax.table(taxonomy_tibble) # Create a taxonomy phyloseq object
samples.object = sample.table(fractions) # Create a samples phyloseq object
phylo.qSIP = phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
```

##### Example of scaling plot
``` {r rlm regression plot, echo = FALSE, message=FALSE, warning = FALSE}
mag_tab_scaled$plots$plots[[1]]
```

#### lm scaling of coverage values
Scale cover values to absolute abundance using the linear regression model. In this workflow, if the data is noisy, users have the option filter data using Cooks' distance, based on the typical 4/n threshold. Data with cook's distance > 4/n will be filtered out (n is the number of observations). THis can be done using the option `cook_filtering = TRUE`.


```{r lm scaling, eval=FALSE}
taxonomy_tibble = rbind(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if necessary
#mag_tab is a tibble with absolute concentrations of MAGs obtained by scaling MAG coverages using linear regression models on sequin coverages and concentration


##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#Set cook_filtering = FALSE to avoid filtering data based on Cooks distance
mag_tab_scaled <- scale_features_lm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation, cook_filtering = TRUE)

mag_tab = as.matrix(mag_tab_scaled$mag_tab) #Extract absolute abundances as a matrix
#mag_tab = as.matrix(mag_tab) #Ensuring input for phyloseq OTU table is in a matrix format
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table

taxonomy.object = tax.table(taxonomy_tibble) # Create a taxonomy phyloseq object
samples.object = sample.table(fractions) # Create a samples phyloseq object
phylo.qSIP = phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
```


## Phase 2 - Statistical analyses and qSIP

The bootstrapping function is based upon the [HTSSIP package] (https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0189616)

Statistical analyses such as multiple hypothesis testing could used to identify isotope incorporating taxa. Briefly, t-tests are conducted and false dectection rate (FDR) correction is performed on the multiple hypothesis testing to estimate FDR adjusted p-values. Based on a user specified significance level, isotope incorporating MAGs can be calculated. Additionally, qSIP methods proposed by Hungate et al. (2015) can also be used. With qSIP methods, isotpoic enrichment can be calculated. Finally, both methods can be combined to estimate isotopic enrichment using bootstrapped atom fraction excess values and FDR adjusted multiple hypothesis testing can be done to identify isotope incorporating MAGs.

### Bootstrapped AFE approach using qSIP principles by Hungate et al. (2015)

Calculate atom fraction excess. By bootstrapping confidence intervals, determine incorporators

```{r Calculate atom fraction excess, warning=FALSE, message=FALSE}
atomX = qSIP_atom_excess_MAGs(phylo.qSIP,
                               control_expr='Isotope=="12C"',
                               treatment_rep='Replicate',
                               Gi = GC_content)
#Bootstrap confidence intervals
df_atomX_boot = HTSSIP::qSIP_bootstrap(atomX, n_boot=100, parallel = TRUE) #Change "parallel = FALSE" to compute using a single-core
df_atomX_boot %>% head
CI_threshold = 0
df_atomX_boot = df_atomX_boot %>%
  mutate(Incorporator = A_CI_low > CI_threshold,
         OTU = reorder(OTU, -A))
#Get incorporator info
n_incorp = df_atomX_boot %>%
  filter(Incorporator == TRUE) %>%
  nrow 
#Get incorporator list
incorporator_list = incorporators_taxonomy(taxonomy = taxonomy_tibble, bootstrapped_AFE_table = df_atomX_boot)
#Print incorporator information
cat('Number of incorporators:', n_incorp, '\n')
cat('Incorporators: \n')
incorporator_list
```

Plot the atom fraction excess plot

```{r Plot atom fraction excess, warning=FALSE, message=FALSE, comment=FALSE}
(atom_f_excess_plot = ggplot(df_atomX_boot, aes(OTU, A, ymin=A_CI_low, ymax=A_CI_high, color=Incorporator)) +
  geom_pointrange(size=0.25) +
  geom_linerange() +
  geom_hline(yintercept=0, linetype='dashed', alpha=0.5) +
  labs(x='MAGs', y='Atom fraction excess') +
  theme_bw() +
  coord_flip() +
  ggtitle("Isotope incorporating MAGs"))
ggsave(filename = "atom_fration_excess.pdf", plot = atom_f_excess_plot, path = ".")
```


### Alternative method to identify incorporators - Using multiple hypothesis testing with false detection rate correction

Multiple hypothesis testing is based on t-tests and FDR correction is done using the package `fdrtool`. The user has the option to choose either of the statistical tests to run. But to calculate isotopic enrichment based on the qSIP mathematical mode, run the above script too to calculate AFE.
``` {r FDR multiple hypothesis testing, fig.show = 'hide',warning=FALSE, message=FALSE, comment = FALSE}

multiple_testing_table = fdr_multiple_hypothesis_testing(atomX = atomX, alpha = 0.05)

incorporator_table = multiple_testing_table %>% inner_join(df_atomX_boot %>% select(-Incorporator))
```

Plot with isotope incorporators determined by FDR adjusted multiple hypothesis testing

```{r fdr adjusted multiple hypothesis testing plot, echo = FALSE, message=FALSE, warning = FALSE}
ggplot(incorporator_table, aes(OTU, A, ymin=A_CI_low, ymax=A_CI_high, color=incorporator)) +
  geom_pointrange(size=0.25) +
  geom_linerange() +
  geom_hline(yintercept=0, linetype='dashed', alpha=0.5) +
  labs(x='MAGs', y='Atom fraction excess') +
  theme_bw() +
  coord_flip() +
  ggtitle("Isotope incorporating MAGs")
```

Classical SIP style plots which show abundance throughout the buoyant density gradient can be obtained using a workflow as below. This can be edited as required to fit the number of replicates. This example provides a script for triplicate samples. The final otput from this script is a tibble which contains abundance and buoyant density gradients for each replicate for each isotope incorporating MAG. Plots are provided with mean buoyant density on the X-axis and mean and standard deviation of absolute abundance on the Y-axis for the triplicate samples. Also, a similar plot but for each replicate is also provided. All plots would be saved in a specified folder.

```{r BD_vs_abundance plot function, warning=FALSE}
plot_abundance = function(incorporator_list, fractions, mag_tab) {
dir.create("abundance_plots")
  #Rename first column of `incorporator_list_rename` tibble to Feature from OTU
  incorporator_list_renamed = incorporator_list %>%
    dplyr::rename("Feature" = "OTU")
  #Reformat mag_tab to make rownames in this tibble as column names with the column name Feature
  mag_tab_reformatted = as.data.frame(mag_tab) %>%
    tibble::rownames_to_column(var = "Feature")
  #Make a tibble by joining abundance and MAG names from incorporator list
  incorporator_abs_abundance = incorporator_list_renamed %>%
    dplyr::inner_join(mag_tab_reformatted, by = "Feature")
  #Pivot the tibble to later access abundance values of every Bin in every sample
  #Store this as a temporary tibble
  long_cov = incorporator_abs_abundance %>%
    tidyr::pivot_longer(fractions$Sample, names_to = "Sample", values_to = "Abundance")
  #Keep Feature and taxonomy columns only
  incorporator_abs_abundance = incorporator_abs_abundance %>%
    dplyr::select(.data$Feature, .data$Taxonomy)
  
  #Create a tibble within the previous tibble to access abundances of each MAG in every sample
  incorporator_abs_abundance = incorporator_abs_abundance %>%
    dplyr::mutate(
      abs_abundance = purrr::map(Feature, ~ dplyr::filter(long_cov, Feature == .x) %>%
                                   dplyr::select(Sample, Abundance))
    )
  #Populate the corresponding fraction, BD, Replicate, and Isotope information
  #for all samples. This gives coverage values for a certain replicate, in a certain BD fraction, for a particular isotope treatment
  #for all MAGs
  incorporator_abs_abundance = incorporator_abs_abundance %>%
    dplyr::mutate(
      abs_abundance = purrr::map(abs_abundance, ~ dplyr::mutate(.x, Isotope = fractions$Isotope,
                                                                      Fraction = fractions$Fraction,
                                                                      Buoyant_density = fractions$Buoyant_density,
                                                                      Rep = stringr::str_split_fixed(fractions$Sample, pattern = "_", n= Inf)[,3]))
    )
  #Summarise the mean abundance, standard deviation of abundance, and mean BD for each fraction and isotope treatment
  incorporator_abs_abundance = incorporator_abs_abundance %>%
    dplyr::mutate(
      summary_coverage = purrr::map(.data$abs_abundance, ~ dplyr::group_by(.x, Fraction, Isotope ) %>%
                                      dplyr::summarise(mean_abs_abundance = mean(Abundance),
                                                       mean_BD = mean(Buoyant_density),
                                                       sd_abs_abundance = stats::sd(Abundance))),
      summary_coverage = purrr::map(.data$summary_coverage, ~ dplyr::arrange(.x, Isotope))
      
    )
  #Plot abundance vs BD and save the plots in the current path
  incorporator_abs_abundance = incorporator_abs_abundance %>%
    dplyr::mutate(
      plots = purrr::map(.data$summary_coverage, ~ ggplot2::ggplot(data = .x, aes(x = mean_BD, y = mean_abs_abundance)) +
                           geom_point(aes(color = Isotope)) +
                           geom_line(aes(color = Isotope)) +
                           geom_errorbar(aes(ymin = mean_abs_abundance - sd_abs_abundance,
                                             ymax = mean_abs_abundance + sd_abs_abundance)) +
                           ylab("Mean absolute \n abundance (attamole/uL)") +
                           xlab("Mean buoyant \n density (g/mL)") +
                           theme_bw()),
      save_plots = purrr::map2(.data$plots, .data$Feature,  ~ ggplot2::ggsave(filename = paste("mean_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/"))
    )
  
  incorporator_abs_abundance = incorporator_abs_abundance %>%
    dplyr::mutate(
      plots_Rep1_df = purrr::map(.data$abs_abundance, ~ dplyr::filter(.x, Rep == 1)),
      plots_Rep2_df = purrr::map(.data$abs_abundance, ~ dplyr::filter(.x, Rep == 2)),
      plots_Rep3_df = purrr::map(.data$abs_abundance, ~ dplyr::filter(.x, Rep == 3)))
  
  incorporator_abs_abundance = incorporator_abs_abundance %>%
    mutate(plots_Rep1 = 
             purrr::map(.data$plots_Rep1_df, 
                        ~ ggplot2:: ggplot(data = .x,aes(x = Buoyant_density, y = Abundance)) +
                          geom_point(aes(color = Rep, shape = Isotope)) +
                          geom_line(aes(color = Isotope)) +
                          ylab("Absolute \n abundance (attamole/uL)") +
                          xlab("Buoyant \n density (g/mL)") +
                          theme_bw()),
           plots_Rep2 = 
             purrr::map(.data$plots_Rep2_df, 
                        ~ ggplot2:: ggplot(data = .x,aes(x = Buoyant_density, y = Abundance)) +
                          geom_point(aes(color = Rep, shape = Isotope)) +
                          geom_line(aes(color = Isotope)) +
                          ylab("Absolute \n abundance (attamole/uL)") +
                          xlab("Buoyant \n density (g/mL)") +
                          theme_bw()),
           plots_Rep3 = 
             purrr::map(.data$plots_Rep3_df, 
                        ~ ggplot2:: ggplot(data = .x,aes(x = Buoyant_density, y = Abundance)) +
                          geom_point(aes(color = Rep, shape = Isotope)) +
                          geom_line(aes(color = Isotope)) +
                          ylab("Absolute \n abundance (attamole/uL)") +
                          xlab("Buoyant \n density (g/mL)") +
                          theme_bw()),
           save_plots = purrr::map2(.data$plots_Rep1, .data$Feature,  ~ ggplot2::ggsave(filename = paste("Rep_1_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/")),
           save_plots = purrr::map2(.data$plots_Rep2, .data$Feature,  ~ ggplot2::ggsave(filename = paste("Rep_2_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/")),
           save_plots = purrr::map2(.data$plots_Rep3, .data$Feature,  ~ ggplot2::ggsave(filename = paste("Rep_3_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/")))
  
return(incorporator_abs_abundance)
}
```

```{r BD_vs_abundance plot, message=FALSE, warning=FALSE}
BD_plots = plot_abundance(incorporator_list, fractions, mag_tab)
BD_plots$plots