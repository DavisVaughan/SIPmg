dplyr::select(Feature, Coverage, Concentration)),
grouped_seq_cov = purrr::map2(grouped_seq_cov, Dilution, ~ dplyr::mutate(.x, Concentration = Concentration/.y) %>%
dplyr::group_by(Concentration) %>%
dplyr::summarise(mean_cov = mean(Coverage),
sd_cov = stats::sd(Coverage)) %>%
dplyr::na_if(0) %>%
dplyr::mutate(coe_var = sd_cov*100/mean_cov) %>%
dplyr::mutate(threshold_detection = coe_var <= coe_of_variation))) %>%
#Create a list of samples in which sequins were not detected
dplyr::mutate(under_detected = purrr::map(grouped_seq_cov, ~.x %>%
dplyr::filter(is.na(mean_cov)) %>%
dplyr::select(Concentration))
) %>%
# perform linear regression on coverage vs conc., extract rlm params, make plots
dplyr::mutate(
seq_cov_filt = purrr::map2(seq_cov,grouped_seq_cov, ~ dplyr::inner_join(.x, .y , by = "Concentration") %>%
dplyr::filter(., Coverage > 0)),
seq_cov_filt = purrr::map2(seq_cov_filt, lod, ~.x %>%
dplyr::filter(Concentration >= .y) %>%
dplyr::filter(., coe_var <= coe_of_variation) %>% #remove zero coverage values before rlm
dplyr::mutate(
lod = .y)))
View(scale_fac[[13]][[1]])
View(scale_fac[[13]][[1]] %>% select(-c(Length,Sequence,GC_content)))
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
#Load required libraries
library(tidyverse)
library(phyloseq)
library(HTSSIP)
library(data.table)
library(ggpubr)
library(qSIPmg)
set.seed(seed = 1000)
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#For rlm scaling using scale_features_rlm
#For rlm scaling using scale_features_lm
mag_tab_scaled <- scale_features_rlm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation)
## Load data
#Coverage metadata
#Uncomment if your coverage data is in the format mentioned above for this file. Remains commented if you are using the output from `checkm coverage`
f_tibble <- read_csv("mock_input_data/coverage_metadata.csv")
#Sequins metadata
sequins <- read_csv(file="mock_input_data/sequins_metadata.csv")
#Dilutions data
seq_dil = read_csv(file = "mock_input_data/dilutions_data.csv")
#Log scale BOOLEAN. True or False depending on how you would want the MAG coverages to be scaled. Select TRUE if you need MAG concentrations scaled on the log scale
log_scale = TRUE
#coe_of_variation. Acceptable coefficient of variation for coverage and detection (eg. 20 - for 20 % threshold of coefficient of variation) (Coverages above the threshold value will be flagged in the plots)
coe_of_variation = 20
#Taxonomy
gtdbtk_bac_summary = read_delim("mock_input_data/gtdbtk.bac120.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
gtdbtk_archaea = read_delim("mock_input_data/gtdbtk.ar122.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
#GC content
GC_content <- read_csv(file = "mock_input_data/GC_content.csv")
#Fractions
fractions = read_csv("mock_input_data/fractions.csv")
taxonomy_tibble = rbind(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if it has not been done yet
#mag_tab is a tibble with absolute concentrations of MAGs obtained by scaling MAG coverages using linear regression models on sequin coverages and concentration
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#For rlm scaling using scale_features_rlm
#For rlm scaling using scale_features_lm
mag_tab_scaled <- scale_features_rlm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation)
mag_tab = as.matrix(mag_tab_scaled$mag_tab) #Extract absolute abundances as a matrix
View(scale_fac$cov_tab[[1]])
View(mag_tab)
View(mag_tab %>% rownames_to_column(var = "Feature"))
View(as.data.frame(mag_tab) %>% rownames_to_column(var = "Feature"))
View(as.data.frame(mag_tab) %>% rownames_to_column(var = "Feature") %>% select(Feature, 12C_rep_1_fraction_1))
View(as.data.frame(mag_tab) %>% rownames_to_column(var = "Feature") %>% select(c(Feature, 12C_rep_1_fraction_1)))
a = as.data.frame(mag_tab)
a = a %>% select(`12C_rep_1_fraction_1)
a = a %>% select(`12C_rep_1_fraction_1`)
a = a %>% rownames_to_column(var = "Feature")
View(a)
data.table::setnames(a, old = "12C_rep_1_fraction_1", new = "Concentratio (attaM)")
a = inner_join(a, scale_fac$cov_tab[[1]])
a = as.data.frame(mag_tab)
a = a %>% select(`12C_rep_1_fraction_1`)
a = a %>% rownames_to_column(var = "Feature")
data.table::setnames(a, old = "12C_rep_1_fraction_1", new = "Concentratio (attaM)")
a = inner_join(scale_fac$cov_tab[[1]],a)
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table
taxonomy.object = tax.table(taxonomy_tibble) # Create a taxonomy phyloseq object
samples.object = sample.table(fractions) # Create a samples phyloseq object
phylo.qSIP = phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
atomX = qSIP_atom_excess_MAGs(phylo.qSIP,
control_expr='Isotope=="12C"',
treatment_rep='Replicate',
Gi = GC_content)
#Bootstrap confidence intervals
df_atomX_boot = qSIP_bootstrap(atomX, n_boot=100, parallel = TRUE) #Change "parallel = FALSE" to compute using a single-core
View(df_atomX_boot)
View(atomX$W[[1]])
View(atomX$W)
df_atomX_boot = df_atomX_boot %>% mutate(A_delbd = Z/0.036)
multiple_testing_table = fdr_multiple_hypothesis_testing(atomX = atomX, alpha = 0.05)
incorporator_list_MT = multiple_testing_table %>%
select(OTU, incorporator) %>%
filter(incorporator == TRUE)
n_incorp_MT = nrow(incorporator_list_MT)
AFE_incorporators_MT = multiple_testing_table %>% inner_join(df_atomX_boot)
View(AFE_incorporators_MT)
AFE_incorporators_MT = inner_join(df_atomX_boot,multiple_testing_table)
View(AFE_incorporators_MT[[13]][[1]])
multiple_testing_table = fdr_multiple_hypothesis_testing(atomX = atomX, alpha = 0.05)
AFE_incorporators_MT = inner_join(df_atomX_boot,multiple_testing_table)
View(multiple_testing_table)
multiple_testing_table = fdr_multiple_hypothesis_testing(atomX = atomX, alpha = 0.01)
multiple_testing_table = fdr_multiple_hypothesis_testing(atomX = atomX, alpha = 0.005)
?stats::t.test
?fdrtool::fdrtool()
library(tidyverse)
scale_fac <- dplyr::tibble(Sample = names(f_tibble) %>%
stringr::str_subset(pattern = "Feature", negate = TRUE))
# Merge dilution factors for samples, add log-scaling option
scale_fac <- scale_fac %>%
dplyr::inner_join(seq_dil, by = "Sample") %>%
dplyr::mutate(log_scale = T)
# Make coverage table for features
scale_fac <- scale_fac %>%
dplyr::mutate(
cov_tab = purrr::map(Sample, ~ dplyr::select(f_tibble, Feature, all_of(.))), # Make list of coverage tables for samples
cov_tab = purrr::map(cov_tab, ~stats::setNames(., c("Feature", "Coverage")))  #get rid of sample name in header
) %>%
# merge sequins with coverage tables, remove them from mag/feature table
dplyr::mutate(
seq_cov = purrr::map(cov_tab, ~ dplyr::inner_join(., sequins, by = "Feature")),
mag_cov = purrr::map(cov_tab, ~ dplyr::anti_join(., sequins, by = "Feature"))
)  %>%
# scale sequin concentrations based on dilution factors
dplyr::mutate(
seq_cov = purrr::map2(seq_cov, Dilution, ~ dplyr::mutate(.x, Concentration = Concentration / .y))
) %>%
# Determine groups of spike-in concentrations
dplyr::mutate(
seq_group = purrr::map(seq_cov, ~.x %>% dplyr::group_by(Concentration) %>%
dplyr::tally(name="standards"))
) %>%
# determine limit of detection of spike-ins, based on presence of 5 sequins per conc.
dplyr::mutate(
#determine lowest concentration where at least 1 sequins is detected
lod = purrr::map_dbl(seq_cov, ~ dplyr::filter(., Coverage > 0) %>%
dplyr::group_by(., Concentration) %>%
dplyr::tally(name="detected") %>%
dplyr::summarise(Min = min(Concentration)) %>%
dplyr::pull(Min)),
#create tibble comparing number of observed and theoretical spike ins
seq_det = purrr::map2(seq_cov, seq_group, ~ dplyr::filter(., Coverage > 0) %>%
dplyr::group_by(., Concentration) %>%
dplyr::tally(name="detected") %>%
dplyr::inner_join(.y, by = "Concentration")),
# determine difference between standards and observed spike ins
seq_det = purrr::map(seq_det, ~ dplyr::mutate(., diff = standards - detected)),
seq_warning = purrr::map_int(seq_det, ~ dplyr::summarise(., Sum = sum(diff)) %>%
dplyr::pull(Sum)) #positive values give warning later
) %>%
# Calculate mean, standard deviation, and coeefficient of variation for groups of sequins
# Create a logical vector determining if the sequin is within the threshold
dplyr::mutate(
grouped_seq_cov = purrr::map(cov_tab, ~ dplyr::inner_join(., sequins, by = "Feature") %>%
dplyr::select(Feature, Coverage, Concentration)),
grouped_seq_cov = purrr::map2(grouped_seq_cov, Dilution, ~ dplyr::mutate(.x, Concentration = Concentration/.y) %>%
dplyr::group_by(Concentration) %>%
dplyr::summarise(mean_cov = mean(Coverage),
sd_cov = stats::sd(Coverage)) %>%
dplyr::na_if(0) %>%
dplyr::mutate(coe_var = sd_cov*100/mean_cov) %>%
dplyr::mutate(threshold_detection = coe_var <= coe_of_variation))) %>%
#Create a list of samples in which sequins were not detected
dplyr::mutate(under_detected = purrr::map(grouped_seq_cov, ~.x %>%
dplyr::filter(is.na(mean_cov)) %>%
dplyr::select(Concentration))
) %>%
# perform linear regression on coverage vs conc., extract rlm params, make plots
dplyr::mutate(
seq_cov_filt = purrr::map2(seq_cov,grouped_seq_cov, ~ dplyr::inner_join(.x, .y , by = "Concentration") %>%
dplyr::filter(., Coverage > 0)),
seq_cov_filt = purrr::map2(seq_cov_filt, lod, ~.x %>%
dplyr::filter(Concentration >= .y) %>%
dplyr::filter(., coe_var <= coe_of_variation) %>% #remove zero coverage values before rlm
dplyr::mutate(
lod = .y))) %>%
dplyr::mutate(
fit = ifelse(log_scale == "TRUE" , # check log_trans input
purrr::map(seq_cov_filt, ~ MASS::rlm(log10(Concentration) ~ log10(Coverage) , data = .)), #log rlm if true
purrr::map(seq_cov_filt, ~ MASS::rlm((Concentration) ~ (Coverage) , data = .)) # rlm if false
),
slope = purrr::map_dbl(fit, ~ summary(.)$coef[2]), # get slope
intercept = purrr::map_dbl(fit, ~summary(.)$coef[1]) # get intercept
) %>%
#plot linear regressions
dplyr::mutate(
plots = ifelse(log_scale == "TRUE" , # check log_trans input
purrr::map(seq_cov_filt, # log-scaled plot if true
~ ggplot2::ggplot(data=. , aes(x=log10(Coverage), y= log10(Concentration))) +
geom_point(aes(shape = threshold_detection)) +
geom_smooth(method = MASS::rlm) +
ggpubr::stat_regline_equation(label.x= -0.1, label.y = 3) +
ggpubr::stat_cor(aes(label = paste(..rr.label.., ..p.label.., sep = "~`,`~")), label.x = -0.1, label.y = 3.5) +
xlab("Coverage (log[read depth])") +
ylab("DNA Concentration (log[attamoles/uL])") +
scale_shape(name = "Coefficient of variation", labels = c(paste("below the threshold (",coe_of_variation,")"), paste("above the threshold(",coe_of_variation,")"))) +
theme_bw() +
theme(legend.position = "top")
),
purrr::map(seq_cov_filt, # non-scaled plot if true
~ ggplot2::ggplot(data=. , aes(x=Coverage, y= Concentration)) +
geom_point(aes(shape = threshold_detection)) +
geom_smooth(method = MASS::rlm) +
ggpubr::stat_regline_equation(label.x= 0, label.y = 1000) +
ggpubr::stat_cor(aes(label = paste(..rr.label.., ..p.label.., sep = "~`,`~")), label.x = 0, label.y = 100000) +
xlab("Coverage (read depth)") +
ylab("DNA Concentration (attamoles/uL)") +
scale_shape(name = "Coefficient of variation", labels = c(paste("below the threshold (",coe_of_variation,")"), paste("above the threshold(",coe_of_variation,")"))) +
theme_bw()
)
)
)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
## Load data
#Coverage metadata
#Uncomment if your coverage data is in the format mentioned above for this file. Remains commented if you are using the output from `checkm coverage`
f_tibble <- read_csv("mock_input_data/coverage_metadata.csv")
#Sequins metadata
sequins <- read_csv(file="mock_input_data/sequins_metadata.csv")
#Dilutions data
seq_dil = read_csv(file = "mock_input_data/dilutions_data.csv")
#Log scale BOOLEAN. True or False depending on how you would want the MAG coverages to be scaled. Select TRUE if you need MAG concentrations scaled on the log scale
log_scale = TRUE
#coe_of_variation. Acceptable coefficient of variation for coverage and detection (eg. 20 - for 20 % threshold of coefficient of variation) (Coverages above the threshold value will be flagged in the plots)
coe_of_variation = 20
#Taxonomy
gtdbtk_bac_summary = read_delim("mock_input_data/gtdbtk.bac120.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
gtdbtk_archaea = read_delim("mock_input_data/gtdbtk.ar122.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
#GC content
GC_content <- read_csv(file = "mock_input_data/GC_content.csv")
#Fractions
fractions = read_csv("mock_input_data/fractions.csv")
taxonomy_tibble = rbind(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if it has not been done yet
#mag_tab is a tibble with absolute concentrations of MAGs obtained by scaling MAG coverages using linear regression models on sequin coverages and concentration
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#For rlm scaling using scale_features_rlm
#For rlm scaling using scale_features_lm
mag_tab_scaled <- scale_features_rlm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation)
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#For rlm scaling using scale_features_rlm
#For rlm scaling using scale_features_lm
mag_tab_scaled <- qSIPmg::scale_features_rlm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation)
View(scale_fac)
View(scale_fac$seq_cov_filt[[1]])
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#For rlm scaling using scale_features_rlm
#For rlm scaling using scale_features_lm
mag_tab_scaled <- scale_features_rlm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation)
library(qSIPmg)
mag_tab = as.matrix(mag_tab_scaled$mag_tab) #Extract absolute abundances as a matrix
#mag_tab = as.matrix(mag_tab) #Ensuring input for phyloseq OTU table is in a matrix format
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table
taxonomy.object = tax.table(taxonomy_tibble) # Create a taxonomy phyloseq object
samples.object = sample.table(fractions) # Create a samples phyloseq object
phylo.qSIP = phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
mag_tab_scaled$plots$plots[[1]]
taxonomy_tibble = rbind(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if necessary
#mag_tab is a tibble with absolute concentrations of MAGs obtained by scaling MAG coverages using linear regression models on sequin coverages and concentration
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#Set cook_filtering = FALSE to avoid filtering data based on Cooks distance
mag_tab_scaled <- scale_features_lm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation, cook_filtering = TRUE)
mag_tab = as.matrix(mag_tab_scaled$mag_tab) #Extract absolute abundances as a matrix
#mag_tab = as.matrix(mag_tab) #Ensuring input for phyloseq OTU table is in a matrix format
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table
taxonomy.object = tax.table(taxonomy_tibble) # Create a taxonomy phyloseq object
samples.object = sample.table(fractions) # Create a samples phyloseq object
phylo.qSIP = phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
atomX = qSIP_atom_excess_MAGs(phylo.qSIP,
control_expr='Isotope=="12C"',
treatment_rep='Replicate',
Gi = GC_content)
#Bootstrap confidence intervals
df_atomX_boot = HTSSIP::qSIP_bootstrap(atomX, n_boot=100, parallel = TRUE) #Change "parallel = FALSE" to compute using a single-core
df_atomX_boot %>% head
CI_threshold = 0
df_atomX_boot = df_atomX_boot %>%
mutate(Incorporator = A_CI_low > CI_threshold,
OTU = reorder(OTU, -A))
#Get incorporator info
n_incorp = df_atomX_boot %>%
filter(Incorporator == TRUE) %>%
nrow
#Get incorporator list
incorporator_list = incorporators_taxonomy(taxonomy = taxonomy_tibble, bootstrapped_AFE_table = df_atomX_boot)
#Print incorporator information
cat('Number of incorporators:', n_incorp, '\n')
cat('Incorporators: \n')
incorporator_list
plot_abundance = function(incorporator_list, fractions, mag_tab) {
dir.create("abundance_plots")
#Rename first column of `incorporator_list_rename` tibble to Feature from OTU
incorporator_list_renamed = incorporator_list %>%
dplyr::rename("Feature" = "OTU")
#Reformat mag_tab to make rownames in this tibble as column names with the column name Feature
mag_tab_reformatted = as.data.frame(mag_tab) %>%
tibble::rownames_to_column(var = "Feature")
#Make a tibble by joining abundance and MAG names from incorporator list
incorporator_abs_abundance = incorporator_list_renamed %>%
dplyr::inner_join(mag_tab_reformatted, by = "Feature")
#Pivot the tibble to later access abundance values of every Bin in every sample
#Store this as a temporary tibble
long_cov = incorporator_abs_abundance %>%
tidyr::pivot_longer(fractions$Sample, names_to = "Sample", values_to = "Abundance")
#Keep Feature and taxonomy columns only
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::select(.data$Feature, .data$Taxonomy)
#Create a tibble within the previous tibble to access abundances of each MAG in every sample
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
abs_abundance = purrr::map(Feature, ~ dplyr::filter(long_cov, Feature == .x) %>%
dplyr::select(Sample, Abundance))
)
#Populate the corresponding fraction, BD, Replicate, and Isotope information
#for all samples. This gives coverage values for a certain replicate, in a certain BD fraction, for a particular isotope treatment
#for all MAGs
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
abs_abundance = purrr::map(abs_abundance, ~ dplyr::mutate(.x, Isotope = fractions$Isotope,
Fraction = fractions$Fraction,
Buoyant_density = fractions$Buoyant_density,
Rep = stringr::str_split_fixed(fractions$Sample, pattern = "_", n= Inf)[,3]))
)
#Summarise the mean abundance, standard deviation of abundance, and mean BD for each fraction and isotope treatment
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
summary_coverage = purrr::map(.data$abs_abundance, ~ dplyr::group_by(.x, Fraction, Isotope ) %>%
dplyr::summarise(mean_abs_abundance = mean(Abundance),
mean_BD = mean(Buoyant_density),
sd_abs_abundance = stats::sd(Abundance))),
summary_coverage = purrr::map(.data$summary_coverage, ~ dplyr::arrange(.x, Isotope))
)
#Plot abundance vs BD and save the plots in the current path
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
plots = purrr::map(.data$summary_coverage, ~ ggplot2::ggplot(data = .x, aes(x = mean_BD, y = mean_abs_abundance)) +
geom_point(aes(color = Isotope)) +
geom_line(aes(color = Isotope)) +
geom_errorbar(aes(ymin = mean_abs_abundance - sd_abs_abundance,
ymax = mean_abs_abundance + sd_abs_abundance)) +
ylab("Mean absolute \n abundance (attamole/uL)") +
xlab("Mean buoyant \n density (g/mL)") +
theme_bw()),
save_plots = purrr::map2(.data$plots, .data$Feature,  ~ ggplot2::ggsave(filename = paste("mean_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/"))
)
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
plots_Rep1_df = purrr::map(.data$abs_abundance, ~ dplyr::filter(.x, Rep == 1)),
plots_Rep2_df = purrr::map(.data$abs_abundance, ~ dplyr::filter(.x, Rep == 2)),
plots_Rep3_df = purrr::map(.data$abs_abundance, ~ dplyr::filter(.x, Rep == 3)))
incorporator_abs_abundance = incorporator_abs_abundance %>%
mutate(plots_Rep1 =
purrr::map(.data$plots_Rep1_df,
~ ggplot2:: ggplot(data = .x,aes(x = Buoyant_density, y = Abundance)) +
geom_point(aes(color = Rep, shape = Isotope)) +
geom_line(aes(color = Isotope)) +
ylab("Absolute \n abundance (attamole/uL)") +
xlab("Buoyant \n density (g/mL)") +
theme_bw()),
plots_Rep2 =
purrr::map(.data$plots_Rep2_df,
~ ggplot2:: ggplot(data = .x,aes(x = Buoyant_density, y = Abundance)) +
geom_point(aes(color = Rep, shape = Isotope)) +
geom_line(aes(color = Isotope)) +
ylab("Absolute \n abundance (attamole/uL)") +
xlab("Buoyant \n density (g/mL)") +
theme_bw()),
plots_Rep3 =
purrr::map(.data$plots_Rep3_df,
~ ggplot2:: ggplot(data = .x,aes(x = Buoyant_density, y = Abundance)) +
geom_point(aes(color = Rep, shape = Isotope)) +
geom_line(aes(color = Isotope)) +
ylab("Absolute \n abundance (attamole/uL)") +
xlab("Buoyant \n density (g/mL)") +
theme_bw()),
save_plots = purrr::map2(.data$plots_Rep1, .data$Feature,  ~ ggplot2::ggsave(filename = paste("Rep_1_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/")),
save_plots = purrr::map2(.data$plots_Rep2, .data$Feature,  ~ ggplot2::ggsave(filename = paste("Rep_2_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/")),
save_plots = purrr::map2(.data$plots_Rep3, .data$Feature,  ~ ggplot2::ggsave(filename = paste("Rep_3_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/")))
return(incorporator_abs_abundance)
}
plot_abundance(incorporator_list, fractions, mag_tab)
#Rename first column of `incorporator_list_rename` tibble to Feature from OTU
incorporator_list_renamed = incorporator_list %>%
dplyr::rename("Feature" = "OTU")
#Reformat mag_tab to make rownames in this tibble as column names with the column name Feature
mag_tab_reformatted = as.data.frame(mag_tab) %>%
tibble::rownames_to_column(var = "Feature")
#Make a tibble by joining abundance and MAG names from incorporator list
incorporator_abs_abundance = incorporator_list_renamed %>%
dplyr::inner_join(mag_tab_reformatted, by = "Feature")
#Pivot the tibble to later access abundance values of every Bin in every sample
#Store this as a temporary tibble
long_cov = incorporator_abs_abundance %>%
tidyr::pivot_longer(fractions$Sample, names_to = "Sample", values_to = "Abundance")
#Keep Feature and taxonomy columns only
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::select(.data$Feature, .data$Taxonomy)
#Keep Feature and taxonomy columns only
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::select(Feature, Taxonomy)
#Keep Feature and taxonomy columns only
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::select(.data$Feature, .data$taxonomy)
#Create a tibble within the previous tibble to access abundances of each MAG in every sample
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
abs_abundance = purrr::map(Feature, ~ dplyr::filter(long_cov, Feature == .x) %>%
dplyr::select(Sample, Abundance))
)
#Populate the corresponding fraction, BD, Replicate, and Isotope information
#for all samples. This gives coverage values for a certain replicate, in a certain BD fraction, for a particular isotope treatment
#for all MAGs
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
abs_abundance = purrr::map(abs_abundance, ~ dplyr::mutate(.x, Isotope = fractions$Isotope,
Fraction = fractions$Fraction,
Buoyant_density = fractions$Buoyant_density,
Rep = stringr::str_split_fixed(fractions$Sample, pattern = "_", n= Inf)[,3]))
)
#Summarise the mean abundance, standard deviation of abundance, and mean BD for each fraction and isotope treatment
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
summary_coverage = purrr::map(.data$abs_abundance, ~ dplyr::group_by(.x, Fraction, Isotope ) %>%
dplyr::summarise(mean_abs_abundance = mean(Abundance),
mean_BD = mean(Buoyant_density),
sd_abs_abundance = stats::sd(Abundance))),
summary_coverage = purrr::map(.data$summary_coverage, ~ dplyr::arrange(.x, Isotope))
)
#Plot abundance vs BD and save the plots in the current path
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
plots = purrr::map(.data$summary_coverage, ~ ggplot2::ggplot(data = .x, aes(x = mean_BD, y = mean_abs_abundance)) +
geom_point(aes(color = Isotope)) +
geom_line(aes(color = Isotope)) +
geom_errorbar(aes(ymin = mean_abs_abundance - sd_abs_abundance,
ymax = mean_abs_abundance + sd_abs_abundance)) +
ylab("Mean absolute \n abundance (attamole/uL)") +
xlab("Mean buoyant \n density (g/mL)") +
theme_bw()),
save_plots = purrr::map2(.data$plots, .data$Feature,  ~ ggplot2::ggsave(filename = paste("mean_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/"))
)
#Plot abundance vs BD and save the plots in the current path
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
plots = purrr::map(.data$summary_coverage, ~ ggplot2::ggplot(data = .x, aes(x = mean_BD, y = mean_abs_abundance)) +
geom_point(aes(color = Isotope)) +
geom_line(aes(color = Isotope)) +
geom_errorbar(aes(ymin = mean_abs_abundance - sd_abs_abundance,
ymax = mean_abs_abundance + sd_abs_abundance)) +
ylab("Mean absolute \n abundance (attamole/uL)") +
xlab("Mean buoyant \n density (g/mL)") +
theme_bw()))
View(incorporator_abs_abundance$plots[[1]])
incorporator_abs_abundance$plots[[1]]
incorporator_abs_abundance$plots[[2]]
library(xfun)
detach("package:xfun", unload = TRUE)
remove.packages("xfun", lib="~/R/win-library/4.1")
install.packages("xfun")
install.packages("xfun")
library(qSIPmg)
library(qSIPmg)
library(qSIPmg)
library(qSIPmg)
usethis::use_vignette("qSIPmg-vignette")
library(qSIPmg)
library(qSIPmg)
EBImage::readImage("rlm-example.png")
EBImage::readImage("rlm-example.png")
install.packages("~/GitHub/qSIPmg_1.0.0.tar.gz", repos = NULL, type = "source")
browseVignettes("mypackage")
browseVignettes("qSIPmg-vignette")
library(qSIPmg)
library(qSIPmg)
library(qSIPmg)
remove.packages("qSIPmg")
library(qSIPmg)
?qSIPmg::scale_features_lm()
dir
dir()
setwd("~/GitHub/qSIPmg")
library(qSIPmg)
?qSIPmg::scale_features_lm
install.packages("~/GitHub/qSIPmg/qSIPmg_1.0.0.tar.gz", repos = NULL, type = "source")
detach("package:qSIPmg", unload = TRUE)
remove.packages("qSIPmg", lib="~/R/win-library/4.1")
install.packages("~/GitHub/qSIPmg/qSIPmg_1.0.0.tar.gz", repos = NULL, type = "source")
libarary(qSIPmg)
library(qSIPmg)
library(qSIPmg)
library(qSIPmg)
install.packages("roxygen2")
library(SIPmg)
install.packages("~/GitHub/SIPmg_1.0.0.tar.gz", repos = NULL, type = "source")
install.packages("bookdown")
library(SIPmg)
install.packages("EBImage")
#Load required libraries
library(tidyverse)
