## Load data
#Coverage metadata
#Uncomment if your coverage data is in the format mentioned above for this file. Remains commented if you are using the output from `checkm coverage`
f_tibble <- read_csv("mock_input_data/coverage_metadata.csv")
#Sequins metadata
sequins <- read_csv(file="mock_input_data/sequins_metadata.csv")
#Dilutions data
seq_dil = read_csv(file = "mock_input_data/dilutions_data.csv")
#Log scale BOOLEAN. True or False depending on how you would want the MAG coverages to be scaled. Select TRUE if you need MAG concentrations scaled on the log scale
log_scale = TRUE
#coe_of_variation. Acceptable coefficient of variation for coverage and detection (eg. 20 - for 20 % threshold of coefficient of variation) (Coverages above the threshold value will be flagged in the plots)
coe_of_variation = 20
#Taxonomy
gtdbtk_bac_summary = read_delim("mock_input_data/gtdbtk.bac120.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
gtdbtk_archaea = read_delim("mock_input_data/gtdbtk.ar122.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
#GC content
GC_content <- read_csv(file = "mock_input_data/GC_content.csv")
#Fractions
fractions = read_csv("mock_input_data/fractions.csv")
taxonomy_tibble = rbind(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if it has not been done yet
#mag_tab is a tibble with absolute concentrations of MAGs obtained by scaling MAG coverages using linear regression models on sequin coverages and concentration
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#For rlm scaling using scale_features_rlm
#For rlm scaling using scale_features_lm
mag_tab_scaled <- scale_features_rlm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation)
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#For rlm scaling using scale_features_rlm
#For rlm scaling using scale_features_lm
mag_tab_scaled <- qSIPmg::scale_features_rlm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation)
View(scale_fac)
View(scale_fac$seq_cov_filt[[1]])
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#For rlm scaling using scale_features_rlm
#For rlm scaling using scale_features_lm
mag_tab_scaled <- scale_features_rlm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation)
library(qSIPmg)
mag_tab = as.matrix(mag_tab_scaled$mag_tab) #Extract absolute abundances as a matrix
#mag_tab = as.matrix(mag_tab) #Ensuring input for phyloseq OTU table is in a matrix format
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table
taxonomy.object = tax.table(taxonomy_tibble) # Create a taxonomy phyloseq object
samples.object = sample.table(fractions) # Create a samples phyloseq object
phylo.qSIP = phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
mag_tab_scaled$plots$plots[[1]]
taxonomy_tibble = rbind(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if necessary
#mag_tab is a tibble with absolute concentrations of MAGs obtained by scaling MAG coverages using linear regression models on sequin coverages and concentration
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#Set cook_filtering = FALSE to avoid filtering data based on Cooks distance
mag_tab_scaled <- scale_features_lm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation, cook_filtering = TRUE)
mag_tab = as.matrix(mag_tab_scaled$mag_tab) #Extract absolute abundances as a matrix
#mag_tab = as.matrix(mag_tab) #Ensuring input for phyloseq OTU table is in a matrix format
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table
taxonomy.object = tax.table(taxonomy_tibble) # Create a taxonomy phyloseq object
samples.object = sample.table(fractions) # Create a samples phyloseq object
phylo.qSIP = phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
atomX = qSIP_atom_excess_MAGs(phylo.qSIP,
control_expr='Isotope=="12C"',
treatment_rep='Replicate',
Gi = GC_content)
#Bootstrap confidence intervals
df_atomX_boot = HTSSIP::qSIP_bootstrap(atomX, n_boot=100, parallel = TRUE) #Change "parallel = FALSE" to compute using a single-core
df_atomX_boot %>% head
CI_threshold = 0
df_atomX_boot = df_atomX_boot %>%
mutate(Incorporator = A_CI_low > CI_threshold,
OTU = reorder(OTU, -A))
#Get incorporator info
n_incorp = df_atomX_boot %>%
filter(Incorporator == TRUE) %>%
nrow
#Get incorporator list
incorporator_list = incorporators_taxonomy(taxonomy = taxonomy_tibble, bootstrapped_AFE_table = df_atomX_boot)
#Print incorporator information
cat('Number of incorporators:', n_incorp, '\n')
cat('Incorporators: \n')
incorporator_list
plot_abundance = function(incorporator_list, fractions, mag_tab) {
dir.create("abundance_plots")
#Rename first column of `incorporator_list_rename` tibble to Feature from OTU
incorporator_list_renamed = incorporator_list %>%
dplyr::rename("Feature" = "OTU")
#Reformat mag_tab to make rownames in this tibble as column names with the column name Feature
mag_tab_reformatted = as.data.frame(mag_tab) %>%
tibble::rownames_to_column(var = "Feature")
#Make a tibble by joining abundance and MAG names from incorporator list
incorporator_abs_abundance = incorporator_list_renamed %>%
dplyr::inner_join(mag_tab_reformatted, by = "Feature")
#Pivot the tibble to later access abundance values of every Bin in every sample
#Store this as a temporary tibble
long_cov = incorporator_abs_abundance %>%
tidyr::pivot_longer(fractions$Sample, names_to = "Sample", values_to = "Abundance")
#Keep Feature and taxonomy columns only
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::select(.data$Feature, .data$Taxonomy)
#Create a tibble within the previous tibble to access abundances of each MAG in every sample
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
abs_abundance = purrr::map(Feature, ~ dplyr::filter(long_cov, Feature == .x) %>%
dplyr::select(Sample, Abundance))
)
#Populate the corresponding fraction, BD, Replicate, and Isotope information
#for all samples. This gives coverage values for a certain replicate, in a certain BD fraction, for a particular isotope treatment
#for all MAGs
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
abs_abundance = purrr::map(abs_abundance, ~ dplyr::mutate(.x, Isotope = fractions$Isotope,
Fraction = fractions$Fraction,
Buoyant_density = fractions$Buoyant_density,
Rep = stringr::str_split_fixed(fractions$Sample, pattern = "_", n= Inf)[,3]))
)
#Summarise the mean abundance, standard deviation of abundance, and mean BD for each fraction and isotope treatment
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
summary_coverage = purrr::map(.data$abs_abundance, ~ dplyr::group_by(.x, Fraction, Isotope ) %>%
dplyr::summarise(mean_abs_abundance = mean(Abundance),
mean_BD = mean(Buoyant_density),
sd_abs_abundance = stats::sd(Abundance))),
summary_coverage = purrr::map(.data$summary_coverage, ~ dplyr::arrange(.x, Isotope))
)
#Plot abundance vs BD and save the plots in the current path
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
plots = purrr::map(.data$summary_coverage, ~ ggplot2::ggplot(data = .x, aes(x = mean_BD, y = mean_abs_abundance)) +
geom_point(aes(color = Isotope)) +
geom_line(aes(color = Isotope)) +
geom_errorbar(aes(ymin = mean_abs_abundance - sd_abs_abundance,
ymax = mean_abs_abundance + sd_abs_abundance)) +
ylab("Mean absolute \n abundance (attamole/uL)") +
xlab("Mean buoyant \n density (g/mL)") +
theme_bw()),
save_plots = purrr::map2(.data$plots, .data$Feature,  ~ ggplot2::ggsave(filename = paste("mean_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/"))
)
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
plots_Rep1_df = purrr::map(.data$abs_abundance, ~ dplyr::filter(.x, Rep == 1)),
plots_Rep2_df = purrr::map(.data$abs_abundance, ~ dplyr::filter(.x, Rep == 2)),
plots_Rep3_df = purrr::map(.data$abs_abundance, ~ dplyr::filter(.x, Rep == 3)))
incorporator_abs_abundance = incorporator_abs_abundance %>%
mutate(plots_Rep1 =
purrr::map(.data$plots_Rep1_df,
~ ggplot2:: ggplot(data = .x,aes(x = Buoyant_density, y = Abundance)) +
geom_point(aes(color = Rep, shape = Isotope)) +
geom_line(aes(color = Isotope)) +
ylab("Absolute \n abundance (attamole/uL)") +
xlab("Buoyant \n density (g/mL)") +
theme_bw()),
plots_Rep2 =
purrr::map(.data$plots_Rep2_df,
~ ggplot2:: ggplot(data = .x,aes(x = Buoyant_density, y = Abundance)) +
geom_point(aes(color = Rep, shape = Isotope)) +
geom_line(aes(color = Isotope)) +
ylab("Absolute \n abundance (attamole/uL)") +
xlab("Buoyant \n density (g/mL)") +
theme_bw()),
plots_Rep3 =
purrr::map(.data$plots_Rep3_df,
~ ggplot2:: ggplot(data = .x,aes(x = Buoyant_density, y = Abundance)) +
geom_point(aes(color = Rep, shape = Isotope)) +
geom_line(aes(color = Isotope)) +
ylab("Absolute \n abundance (attamole/uL)") +
xlab("Buoyant \n density (g/mL)") +
theme_bw()),
save_plots = purrr::map2(.data$plots_Rep1, .data$Feature,  ~ ggplot2::ggsave(filename = paste("Rep_1_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/")),
save_plots = purrr::map2(.data$plots_Rep2, .data$Feature,  ~ ggplot2::ggsave(filename = paste("Rep_2_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/")),
save_plots = purrr::map2(.data$plots_Rep3, .data$Feature,  ~ ggplot2::ggsave(filename = paste("Rep_3_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/")))
return(incorporator_abs_abundance)
}
plot_abundance(incorporator_list, fractions, mag_tab)
#Rename first column of `incorporator_list_rename` tibble to Feature from OTU
incorporator_list_renamed = incorporator_list %>%
dplyr::rename("Feature" = "OTU")
#Reformat mag_tab to make rownames in this tibble as column names with the column name Feature
mag_tab_reformatted = as.data.frame(mag_tab) %>%
tibble::rownames_to_column(var = "Feature")
#Make a tibble by joining abundance and MAG names from incorporator list
incorporator_abs_abundance = incorporator_list_renamed %>%
dplyr::inner_join(mag_tab_reformatted, by = "Feature")
#Pivot the tibble to later access abundance values of every Bin in every sample
#Store this as a temporary tibble
long_cov = incorporator_abs_abundance %>%
tidyr::pivot_longer(fractions$Sample, names_to = "Sample", values_to = "Abundance")
#Keep Feature and taxonomy columns only
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::select(.data$Feature, .data$Taxonomy)
#Keep Feature and taxonomy columns only
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::select(Feature, Taxonomy)
#Keep Feature and taxonomy columns only
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::select(.data$Feature, .data$taxonomy)
#Create a tibble within the previous tibble to access abundances of each MAG in every sample
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
abs_abundance = purrr::map(Feature, ~ dplyr::filter(long_cov, Feature == .x) %>%
dplyr::select(Sample, Abundance))
)
#Populate the corresponding fraction, BD, Replicate, and Isotope information
#for all samples. This gives coverage values for a certain replicate, in a certain BD fraction, for a particular isotope treatment
#for all MAGs
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
abs_abundance = purrr::map(abs_abundance, ~ dplyr::mutate(.x, Isotope = fractions$Isotope,
Fraction = fractions$Fraction,
Buoyant_density = fractions$Buoyant_density,
Rep = stringr::str_split_fixed(fractions$Sample, pattern = "_", n= Inf)[,3]))
)
#Summarise the mean abundance, standard deviation of abundance, and mean BD for each fraction and isotope treatment
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
summary_coverage = purrr::map(.data$abs_abundance, ~ dplyr::group_by(.x, Fraction, Isotope ) %>%
dplyr::summarise(mean_abs_abundance = mean(Abundance),
mean_BD = mean(Buoyant_density),
sd_abs_abundance = stats::sd(Abundance))),
summary_coverage = purrr::map(.data$summary_coverage, ~ dplyr::arrange(.x, Isotope))
)
#Plot abundance vs BD and save the plots in the current path
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
plots = purrr::map(.data$summary_coverage, ~ ggplot2::ggplot(data = .x, aes(x = mean_BD, y = mean_abs_abundance)) +
geom_point(aes(color = Isotope)) +
geom_line(aes(color = Isotope)) +
geom_errorbar(aes(ymin = mean_abs_abundance - sd_abs_abundance,
ymax = mean_abs_abundance + sd_abs_abundance)) +
ylab("Mean absolute \n abundance (attamole/uL)") +
xlab("Mean buoyant \n density (g/mL)") +
theme_bw()),
save_plots = purrr::map2(.data$plots, .data$Feature,  ~ ggplot2::ggsave(filename = paste("mean_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/"))
)
#Plot abundance vs BD and save the plots in the current path
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
plots = purrr::map(.data$summary_coverage, ~ ggplot2::ggplot(data = .x, aes(x = mean_BD, y = mean_abs_abundance)) +
geom_point(aes(color = Isotope)) +
geom_line(aes(color = Isotope)) +
geom_errorbar(aes(ymin = mean_abs_abundance - sd_abs_abundance,
ymax = mean_abs_abundance + sd_abs_abundance)) +
ylab("Mean absolute \n abundance (attamole/uL)") +
xlab("Mean buoyant \n density (g/mL)") +
theme_bw()))
View(incorporator_abs_abundance$plots[[1]])
incorporator_abs_abundance$plots[[1]]
incorporator_abs_abundance$plots[[2]]
library(xfun)
detach("package:xfun", unload = TRUE)
remove.packages("xfun", lib="~/R/win-library/4.1")
install.packages("xfun")
install.packages("xfun")
library(qSIPmg)
library(qSIPmg)
library(qSIPmg)
library(qSIPmg)
usethis::use_vignette("qSIPmg-vignette")
library(qSIPmg)
library(qSIPmg)
EBImage::readImage("rlm-example.png")
EBImage::readImage("rlm-example.png")
install.packages("~/GitHub/qSIPmg_1.0.0.tar.gz", repos = NULL, type = "source")
browseVignettes("mypackage")
browseVignettes("qSIPmg-vignette")
library(qSIPmg)
library(qSIPmg)
library(qSIPmg)
remove.packages("qSIPmg")
library(qSIPmg)
?qSIPmg::scale_features_lm()
dir
dir()
setwd("~/GitHub/qSIPmg")
library(qSIPmg)
?qSIPmg::scale_features_lm
install.packages("~/GitHub/qSIPmg/qSIPmg_1.0.0.tar.gz", repos = NULL, type = "source")
detach("package:qSIPmg", unload = TRUE)
remove.packages("qSIPmg", lib="~/R/win-library/4.1")
install.packages("~/GitHub/qSIPmg/qSIPmg_1.0.0.tar.gz", repos = NULL, type = "source")
libarary(qSIPmg)
library(qSIPmg)
library(qSIPmg)
library(qSIPmg)
install.packages("roxygen2")
library(SIPmg)
install.packages("~/GitHub/SIPmg_1.0.0.tar.gz", repos = NULL, type = "source")
install.packages("bookdown")
library(SIPmg)
install.packages("EBImage")
#Load required libraries
library(tidyverse)
#Load required libraries
library(tidyverse)
library(phyloseq)
library(HTSSIP)
library(ggpubr)
library(SIPmg)
set.seed(seed = 1000)
## Load data
#Coverage metadata
#Uncomment if your coverage data is in the format mentioned above for this file. Remains commented if you are using the output from `checkm coverage`
f_tibble <- readr::read_csv("mock_input_data/coverage_metadata.csv")
#Sequins metadata
sequins <- readr::read_csv(file="mock_input_data/sequins_metadata.csv")
#Dilutions data
seq_dil = readr::read_csv(file = "mock_input_data/dilutions_data.csv")
#Log scale BOOLEAN. True or False depending on how you would want the MAG coverages to be scaled. Select TRUE if you need MAG concentrations scaled on the log scale
log_scale = TRUE
#coe_of_variation. Acceptable coefficient of variation for coverage and detection (eg. 20 - for 20 % threshold of coefficient of variation) (Coverages above the threshold value will be flagged in the plots)
coe_of_variation = 20
#Taxonomy
gtdbtk_bac_summary = readr::read_delim("mock_input_data/gtdbtk.bac120.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
gtdbtk_archaea = readr::read_delim("mock_input_data/gtdbtk.ar122.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
#GC content
GC_content <- readr::read_csv(file = "mock_input_data/GC_content.csv")
#Fractions
fractions = readr::read_csv("mock_input_data/fractions.csv")
taxonomy_tibble = dplyr::bind_rows(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if it has not been done yet
#mag_tab is a tibble with absolute concentrations of MAGs obtained by scaling MAG coverages using linear regression models on sequin coverages and concentration
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#For rlm scaling using scale_features_rlm
#For rlm scaling using scale_features_lm
mag_tab_scaled <- SIPmg::scale_features_rlm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation)
mag_tab = as.matrix(mag_tab_scaled$mag_tab) #Extract absolute abundances as a matrix
##Load data
#Coverage data
f_tibble <- readr::read_csv("mock_input_data/coverages_outliers.csv")
#Sequins metadata
sequins <- readr::read_csv(file="mock_input_data/sequin_meta_outliers.csv")
#Dilutions data
seq_dil = readr::read_csv(file = "mock_input_data/seq_dilution_outliers.csv")
#Log scale BOOLEAN. True or False depending on how you would want the MAG coverages to be scaled. Select TRUE if you need MAG concentrations scaled on the log scale
log_scale = TRUE
#coe_of_variation. Acceptable coefficient of variation for coverage and detection (eg. 20 - for 20 % threshold of coefficient of variation) (Coverages above the threshold value will be flagged in the plots)
coe_of_variation = 50
mag_tab_scaled_rlm <- SIPmg::scale_features_rlm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation)
mag_tab_scaled_lm <- SIPmg::scale_features_lm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation, cook_filtering = TRUE)
rlm_example = EBImage::readImage("rlm-example.png")
rlm_example = EBImage::resize(rlm_example,dim(rlm_example)[1]/2)
lm_example = EBImage::readImage("lm-example.png")
lm_example = EBImage::resize(lm_example,dim(lm_example)[1]/2)
filtered_lm_example = EBImage::readImage("filtered_lm-example.png")
fitlered_lm_example = EBImage::resize(filtered_lm_example,dim(filtered_lm_example)[1]/2)
cooksd_example = EBImage::readImage("cooksd-example.png")
cooksd_example = EBImage::resize(cooksd_example,dim(cooksd_example)[1]/2)
# Robust linear regression plot
EBImage::display(rlm_example)
#Linear regression plot without filtering sequin data
EBImage::display(lm_example)
taxonomy_tibble = dplyr::bind_rows(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if it has not been done yet
#mag_tab is a tibble with absolute concentrations of MAGs obtained by scaling MAG coverages using linear regression models on sequin coverages and concentration
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#For rlm scaling using scale_features_rlm
#For rlm scaling using scale_features_lm
mag_tab_scaled_lm <- SIPmg::scale_features_lm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation, cook_filtering = TRUE)
mag_tab = as.matrix(mag_tab_scaled_lm$mag_tab) #Extract absolute abundances as a matrix
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table
taxonomy.object = SIPmg::tax.table(taxonomy_tibble) # Create a taxonomy phyloseq object
samples.object = SIPmg::sample.table(fractions) # Create a samples phyloseq object
phylo.qSIP = SIPmg::phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
taxonomy_tibble = dplyr::bind_rows(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if it has not been done yet
taxonomy.object = SIPmg::tax.table(taxonomy_tibble) # Create a taxonomy phyloseq object
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table
samples.object = SIPmg::sample.table(fractions) # Create a samples phyloseq object
phylo.qSIP = SIPmg::phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
taxa_names(phylo.qSIP)
samples.object
taxonomy.object
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table
taxonomy.object = SIPmg::tax.table(taxonomy_tibble)
samples.object = SIPmg::sample.table(fractions) # Create a samples phyloseq object
taxa_names(mag.table)
taxa_names(taxonomy.object)
## Load data
#Coverage metadata
#Uncomment if your coverage data is in the format mentioned above for this file. Remains commented if you are using the output from `checkm coverage`
f_tibble <- readr::read_csv("mock_input_data/coverage_metadata.csv")
#Sequins metadata
sequins <- readr::read_csv(file="mock_input_data/sequins_metadata.csv")
#Dilutions data
seq_dil = readr::read_csv(file = "mock_input_data/dilutions_data.csv")
#Log scale BOOLEAN. True or False depending on how you would want the MAG coverages to be scaled. Select TRUE if you need MAG concentrations scaled on the log scale
log_scale = TRUE
#coe_of_variation. Acceptable coefficient of variation for coverage and detection (eg. 20 - for 20 % threshold of coefficient of variation) (Coverages above the threshold value will be flagged in the plots)
coe_of_variation = 20
#Taxonomy
gtdbtk_bac_summary = readr::read_delim("mock_input_data/gtdbtk.bac120.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
gtdbtk_archaea = readr::read_delim("mock_input_data/gtdbtk.ar122.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
#GC content
GC_content <- readr::read_csv(file = "mock_input_data/GC_content.csv")
#Fractions
fractions = readr::read_csv("mock_input_data/fractions.csv")
taxonomy_tibble = dplyr::bind_rows(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if it has not been done yet
#mag_tab is a tibble with absolute concentrations of MAGs obtained by scaling MAG coverages using linear regression models on sequin coverages and concentration
##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#For rlm scaling using scale_features_rlm
#For rlm scaling using scale_features_lm
mag_tab_scaled_lm <- SIPmg::scale_features_lm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation, cook_filtering = TRUE)
mag_tab = as.matrix(mag_tab_scaled_lm$mag_tab) #Extract absolute abundances as a matrix
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table
taxonomy.object = SIPmg::tax.table(taxonomy_tibble) # Create a taxonomy phyloseq object
samples.object = SIPmg::sample.table(fractions) # Create a samples phyloseq object
phylo.qSIP = SIPmg::phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
atomX = SIPmg::qSIP_atom_excess_MAGs(phylo.qSIP,
control_expr='Isotope=="12C"',
treatment_rep='Replicate',
Gi = GC_content)
#Bootstrap confidence intervals
ncores = 6
doParallel::registerDoParallel(ncores)
df_atomX_boot = SIPmg::qSIP_bootstrap_fcr(atomX, n_boot=10, parallel = T) #Change "parallel = FALSE" to compute using a single-core
#GC content
GC_content <- readr::read_csv(file = "mock_input_data/GC_content.csv")
#Fractions
fractions = readr::read_csv("mock_input_data/fractions.csv")
df_atomX_boot = SIPmg::qSIP_bootstrap_fcr(atomX, n_boot=10, parallel = T) #Change "parallel = FALSE" to compute using a single-core
atomX = SIPmg::qSIP_atom_excess_MAGs(phylo.qSIP,
control_expr='Isotope=="12C"',
treatment_rep='Replicate',
Gi = GC_content)
df_atomX_boot = SIPmg::qSIP_bootstrap_fcr(atomX, n_boot=10) #Change "parallel = FALSE" to compute using a single-core
, parallel = T
df_atomX_boot = SIPmg::qSIP_bootstrap_fcr(atomX, n_boot=10, parallel = T) #Change "parallel = FALSE" to compute using a single-core
df_atomX_boot = SIPmg::qSIP_bootstrap_fcr(atomX, n_boot=10) #Change "parallel = FALSE" to compute using a single-core
CI_threshold = 0
df_atomX_boot = df_atomX_boot %>%
dplyr::mutate(Incorporator_qSIP = A_CI_fcr_low > CI_threshold,
Incorporator_delbd = A_delbd - A_delbd_sd > 0,
OTU = reorder(OTU, -A))
View(df_atomX_boot)
windows = data.frame(density_min=c(1.71,1.72, 1.73),
density_max=c(1.74,1.75,1.76))
padj_cutoff = 0.05
mw.hr.sip = qSIPmg::HRSIP(physeq = phylo.qSIP, design = ~Isotope,
density_windows = windows,
sparsity_threshold = seq(0, 0.3, 0.05),
padj_cutoff = padj_cutoff,
parallel = T)
mw.hr.sip = qSIPmg::HRSIP(physeq = phylo.qSIP, design = ~Isotope,
density_windows = windows,
sparsity_threshold = seq(0, 0.3, 0.05),
padj_cutoff = padj_cutoff)
mw.hr.sip = mw.hr.sip %>%
mutate(incorp = padj < padj_cutoff)
View(mw.hr.sip)
#Get incorporator info
n_qSIP_incorp = df_atomX_boot %>%
dplyr::filter(Incorporator_qSIP == TRUE) %>%
nrow
n_qSIP_incorp
df_atomX_boot = df_atomX_boot %>%
inner_join(taxonomy_tibble)
View(taxonomy_tibble)
df_atomX_boot = df_atomX_boot %>%
inner_join(taxonomy_tibble %>%
select(user_genome, classification) %>%
rename(OTU = user_genome))
??qSIPmg::incorporators_taxonomy()
?qSIPmg::incorporators_taxonomy()
SIPmg::incorporators_taxonomy(df_atomX_boot)
SIPmg::incorporators_taxonomy(bootstrapped_AFE_table = df_atomX_boot, taxonomy = taxonomy_tibble)
qSIP_incorp = df_atomX_boot %>%
select(OTU, classification, A, A_sd, Incorporator_qSIP) %>%
filter(Incorporator_qSIP == TRUE)
qSIP_incorp
View(qSIP_incorp)
n_qSIP_incorp = nrow(qSIP_incorp)
n_qSIP_incorp
delbd_incorp = df_atomX_boot %>%
select(OTU, classification, A_delbd, A_delbd_sd, Incorporator_delbd) %>%
filter(Incorporator_delbd == TRUE)
mw.hr.sip_incorp = mw.hr.sip %>%
filter(incorp == TRUE)
mw.hr.sip_incorp = mw.hr.sip %>%
select(OTU, taxa, incorp) %>%
filter(incorp == TRUE)
n_mw.hr.sip_incorp = nrow(n_mw.hr.sip_incorp)
n_mw.hr.sip_incorp = nrow(mw.hr.sip_incorp)
all_incorp_tibble = full_join(qSIP_incorp, full_join(delbd_incorp, mw.hr.sip_incorp, by = "OTU"), by = "OTU")
View(all_incorp_tibble)
#Get incorporator info
qSIP_incorp = df_atomX_boot %>%
select(OTU, classification, A, A_sd, Incorporator_qSIP) %>%
filter(Incorporator_qSIP == TRUE) %>%
select(-classification)
n_qSIP_incorp = nrow(qSIP_incorp)
delbd_incorp = df_atomX_boot %>%
select(OTU, classification, A_delbd, A_delbd_sd, Incorporator_delbd) %>%
filter(Incorporator_delbd == TRUE) %>%
select(-classification)
n_delbd_incorp = nrow(delbd_incorp)
mw.hr.sip_incorp = mw.hr.sip %>%
select(OTU, taxa, incorp) %>%
filter(incorp == TRUE) %>%
select(-taxa)
n_mw.hr.sip_incorp = nrow(mw.hr.sip_incorp)
all_incorp_tibble = full_join(qSIP_incorp, full_join(delbd_incorp, mw.hr.sip_incorp, by = "OTU"), by = "OTU")
View(all_incorp_tibble)
mw.hr.sip_incorp = mw.hr.sip %>%
select(OTU, taxa, incorp) %>%
filter(incorp == TRUE) %>%
rename("Incorporator_mw_hr.sip" = "incorp") %>%
select(-taxa)
View(mw.hr.sip_incorp)
n_mw.hr.sip_incorp = nrow(mw.hr.sip_incorp)
all_incorp_tibble = full_join(qSIP_incorp, full_join(delbd_incorp, mw.hr.sip_incorp, by = "OTU"), by = "OTU")
install.packages("devtools")
devtools::build_vignettes()
